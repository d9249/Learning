# 2.1_a 정렬후 회전된 배열
# “정렬후 회전된 배열”이란 (5, 8, 9, 2, 3, 4)와 같은 배열을 말한다.
# 즉, 정렬이 된 후에 회전 연산이 0회 이상 적용된 배열이다.
# 회전 연산이란 배열의 마지막 원소가 처음으로 이동하고 나머지 원소들이 오른쪽으로 한 칸씩 이동하는 것을 말한다.
# 예를들어, (2, 3, 4, 5, 8, 9)는 정렬된 배열이고 여기에 회전 연산을 1회 적용하면 (9, 2, 3, 4, 5, 8)이 되고
# 여기에 회전 연산을 추가로 2회 적용하면 (5, 8, 9, 2, 3, 4)가 된다.
# 따라서 (5, 8, 9, 2, 3, 4)는 정렬후 회전된 배열이다.
# (a) 길이가 n인 정렬후 회전된 배열 A [0..n-1]가 주어질 때, 이 배열A에서 최댓값을 찾는 알고리즘을 설계하고, 분석하시오.

A = [2, 3, 4, 5]                    # 해당하는 배열

def MaxValFind(A):
    L = len(A)                      # 배열의 길이
    M = L//2                        # 배열의 중간 인덱스 번호
    if L == 2:                      # 계속해서 나누어가면서 최종적으로 배열의 길이가 2가 되었을 때에는, 
        if A[0] >= A[1]:            # 두개의 원소를 비교했을 때, 큰 값을 리턴한다.
            return A[0]
        else:
            return A[1]
    if A[0] >= A[M]:                # 배열 중간의 원소가 배열의 처음의 원소보다 작을때에는, 
        return MaxValFind(A[:M])    # 중간 원소를 기준으로 나눈 배열의 앞에 최대값이 존재한다는 반증이기 때문에
    else:                           # 중간 원소를 기준으로 슬라이싱하여 나눈 배열을 재귀를 사용해서 풀어낸다.
        return MaxValFind(A[M:])    # 위와 반대의 경우에는 중간값 뒤의 값들이 포함되어 있는 배열을 사용해서 재귀로 풀어낸다.
                                    # 이와 같이 재귀를 반복해 나가면서 최종적으로 2개의 원소가 담긴 배열의 원소 값을 비교하였을 때
                                    # 큰 원소의 값을 return하게 된다면, 해당 결과가 배열의 최대값이다.
print(MaxValFind(A))

# 시간복잡도 : T(n) = T(n/2) + O(1) = O(logn)이다.
# 정확도 : 정렬후 회전된 배열의 어떤 형태를 넣어도 최대값의 원소를 찾을 수 있기 때문에 정확도는 100%라고 볼 수 있다.
